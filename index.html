<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>RU Tetris Sprint 40L</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#05070f;color:#e4e7ff;font-family:"Segoe UI",sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;padding:24px}
button{background:#1b2440;color:#f8f9ff;border:none;padding:12px 24px;border-radius:8px;font-size:16px;cursor:pointer;transition:background .2s;font-weight:600}
button:hover{background:#27335d}
.app{width:100%;max-width:1080px;display:flex;flex-direction:column;gap:24px}
.screen{display:none;flex-direction:column;align-items:center;gap:24px}
.screen.active{display:flex}
.logo{font-size:36px;letter-spacing:6px;text-transform:uppercase;color:#9aa4d9;text-align:center}
.menu-buttons{display:flex;flex-direction:column;gap:16px;width:100%;max-width:320px}
.menu-buttons button{width:100%}
.info-card{background:#0b1020;border-radius:12px;padding:24px;text-align:center;color:#9aa4d9;max-width:420px;line-height:1.5}
.top-bar{display:flex;gap:20px;align-items:center;width:100%;justify-content:space-between}
.top-actions{display:flex;gap:12px;align-items:center}
.stats{display:grid;grid-template-columns:repeat(2,auto);gap:6px 20px;font-size:14px}
.hud-text{color:#aab4dd}
.playfield{display:flex;gap:16px;align-items:flex-start;width:100%;justify-content:center}
.panel{background:#0b1020;border-radius:12px;padding:16px;display:flex;flex-direction:column;align-items:center;gap:12px;min-width:140px}
.panel-title{font-size:14px;letter-spacing:2px;color:#8a94c9}
canvas{background:#0f1628;border-radius:10px}
#boardCanvas{border:2px solid #1d2745}
.overlay{position:fixed;inset:0;background:rgba(5,7,15,.92);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;font-size:18px;text-align:center;z-index:10}
.overlay.hidden{display:none}
.overlay .title{font-size:28px;letter-spacing:4px}
.overlay button{font-size:18px}
.settings-list{width:100%;max-width:520px;display:flex;flex-direction:column;gap:12px}
.settings-row{display:flex;align-items:center;justify-content:space-between;background:#0b1020;padding:16px;border-radius:10px}
.settings-row.listening{outline:2px solid #5dd9ff}
.settings-row .action-label{font-size:16px}
.settings-row button{min-width:160px}
.helper-text{color:#7c86b9;font-size:14px;text-align:center;line-height:1.5}
.placeholder-card{background:#0b1020;padding:24px;border-radius:12px;color:#9aa4d9;text-align:center;max-width:420px;line-height:1.6}
</style>
</head>
<body>
<div class="app">
  <div id="mainMenu" class="screen active">
    <div class="logo">RU Tetris</div>
    <div class="menu-buttons">
      <button id="menuPlayBtn"></button>
      <button id="menuMatchBtn"></button>
      <button id="menuSettingsBtn"></button>
      <button id="menuLoginBtn"></button>
    </div>
    <div class="info-card" id="menuHint"></div>
  </div>

  <div id="gameScreen" class="screen">
    <div class="top-bar">
      <div class="top-actions">
        <button id="gameBackBtn"></button>
      </div>
      <div class="stats">
        <div>LINES</div><div class="hud-text" id="linesVal">0</div>
        <div>TIME</div><div class="hud-text" id="timeVal">00:00.00</div>
        <div>APM</div><div class="hud-text" id="apmVal">0.00</div>
        <div>PPS</div><div class="hud-text" id="ppsVal">0.00</div>
      </div>
    </div>
    <div class="playfield">
      <div class="panel">
        <div class="panel-title">HOLD</div>
        <canvas id="holdCanvas" width="140" height="140"></canvas>
      </div>
      <canvas id="boardCanvas" width="280" height="560"></canvas>
      <div class="panel">
        <div class="panel-title">NEXT</div>
        <canvas id="nextCanvas" width="140" height="420"></canvas>
      </div>
    </div>
  </div>

  <div id="settingsScreen" class="screen">
    <div class="logo" id="settingsTitle"></div>
    <div class="helper-text" id="settingsHint"></div>
    <div class="settings-list" id="settingsList"></div>
    <div class="top-actions">
      <button id="settingsBackBtn"></button>
    </div>
  </div>

  <div id="matchScreen" class="screen">
    <div class="logo" id="matchTitle"></div>
    <div class="placeholder-card" id="matchDescription"></div>
    <button id="matchBackBtn"></button>
  </div>

  <div id="loginScreen" class="screen">
    <div class="logo" id="loginTitle"></div>
    <div class="placeholder-card" id="loginDescription"></div>
    <button id="loginBackBtn"></button>
  </div>
</div>

<div id="resultOverlay" class="overlay hidden">
  <div class="title" id="resultTitle"></div>
  <div id="resultStats"></div>
  <button id="resultMenuBtn"></button>
</div>

<script>
(() => {
const i18n = {
  ru: {
    menu: {
      play40: 'Играть (40 линий)',
      matchmaking: 'Онлайн матчмейкинг',
      settings: 'Настройки управления',
      login: 'Войти',
      hint: 'Соревнуйтесь с собой и улучшайте время прохождения спринта на 40 линий.'
    },
    game: {
      back: 'В меню'
    },
    settings: {
      title: 'Настройки управления',
      hint: 'Нажмите на действие и затем нажмите желаемую клавишу. Настройки сохраняются автоматически.',
      waiting: 'Ожидание ввода...'
    },
    match: {
      title: 'Онлайн матчмейкинг',
      description: 'Система онлайн-матчей находится в разработке. Скоро вы сможете соревноваться с другими игроками!',
      back: 'Назад'
    },
    login: {
      title: 'Войти',
      description: 'Авторизация появится позже. Следите за обновлениями!',
      back: 'Назад'
    },
    result: {
      title: '40 линий завершены!',
      toMenu: 'В меню'
    },
    actions: {
      moveLeft: 'Влево',
      moveRight: 'Вправо',
      softDrop: 'Soft drop',
      hardDrop: 'Hard drop',
      rotateCW: 'Поворот CW',
      rotateCCW: 'Поворот CCW',
      rotate180: 'Поворот 180°',
      hold: 'Холд'
    }
  },
  en: {
    menu: {
      play40: 'Play (40 Lines)',
      matchmaking: 'Online Matchmaking',
      settings: 'Controls',
      login: 'Sign In',
      hint: 'Race against yourself and improve your 40L sprint time.'
    },
    game: {
      back: 'Main Menu'
    },
    settings: {
      title: 'Controls',
      hint: 'Click an action and press a key. The settings are saved automatically.',
      waiting: 'Listening...'
    },
    match: {
      title: 'Online Matchmaking',
      description: 'Multiplayer is under construction. Stay tuned!',
      back: 'Back'
    },
    login: {
      title: 'Sign In',
      description: 'Authentication will arrive in a future update. Stay tuned!',
      back: 'Back'
    },
    result: {
      title: '40 Lines Complete!',
      toMenu: 'Main Menu'
    },
    actions: {
      moveLeft: 'Move left',
      moveRight: 'Move right',
      softDrop: 'Soft drop',
      hardDrop: 'Hard drop',
      rotateCW: 'Rotate CW',
      rotateCCW: 'Rotate CCW',
      rotate180: 'Rotate 180°',
      hold: 'Hold'
    }
  }
};

class Localization {
  constructor(dictionary, lang = 'ru') {
    this.dictionary = dictionary;
    this.lang = lang;
  }
  t(path) {
    const segments = path.split('.');
    let node = this.dictionary[this.lang];
    for (const segment of segments) {
      if (!node) break;
      node = node[segment];
    }
    return node ?? path;
  }
}

class SettingsStore {
  constructor(storageKey, defaults) {
    this.storageKey = storageKey;
    this.defaults = defaults;
    this.data = this.load();
  }
  load() {
    try {
      const raw = localStorage.getItem(this.storageKey);
      if (!raw) return { ...this.defaults };
      const parsed = JSON.parse(raw);
      return { ...this.defaults, ...parsed };
    } catch (err) {
      return { ...this.defaults };
    }
  }
  save() {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (err) {
      /* ignore */
    }
  }
  getBindings() {
    return { ...this.data };
  }
  setBinding(action, keyCode) {
    this.data[action] = keyCode;
    this.save();
  }
  getKeyForAction(action) {
    return this.data[action] ?? null;
  }
}

class ScreenManager {
  constructor() {
    this.current = null;
  }
  show(element) {
    if (this.current === element) return;
    if (this.current) this.current.classList.remove('active');
    this.current = element;
    if (this.current) this.current.classList.add('active');
  }
}

const DEFAULT_BINDINGS = {
  moveLeft: 'ArrowLeft',
  moveRight: 'ArrowRight',
  softDrop: 'ArrowDown',
  hardDrop: 'Space',
  rotateCW: 'KeyX',
  rotateCCW: 'KeyZ',
  rotate180: 'KeyA',
  hold: 'ShiftLeft'
};

const ACTIONS = [
  { id: 'moveLeft', icon: '←' },
  { id: 'moveRight', icon: '→' },
  { id: 'rotateCW', icon: '↻' },
  { id: 'rotateCCW', icon: '↺' },
  { id: 'rotate180', icon: '⟳' },
  { id: 'hardDrop', icon: '⭳' },
  { id: 'softDrop', icon: '⭱' },
  { id: 'hold', icon: '⧖' }
];

class SettingsUI {
  constructor(root, store, locale, onChange) {
    this.root = root;
    this.store = store;
    this.locale = locale;
    this.onChange = onChange;
    this.waitingAction = null;
    this.rows = new Map();
    this.build();
    document.addEventListener('keydown', (event) => this.handleKeydown(event));
  }
  build() {
    this.root.innerHTML = '';
    const bindings = this.store.getBindings();
    ACTIONS.forEach(action => {
      const row = document.createElement('div');
      row.className = 'settings-row';
      row.dataset.action = action.id;

      const label = document.createElement('div');
      label.className = 'action-label';
      label.textContent = `${action.icon} ${this.locale.t(`actions.${action.id}`)}`;

      const btn = document.createElement('button');
      btn.textContent = this.formatKey(bindings[action.id]);
      btn.addEventListener('click', () => this.beginListening(action.id));

      row.appendChild(label);
      row.appendChild(btn);
      this.root.appendChild(row);
      this.rows.set(action.id, { row, btn });
    });
  }
  formatKey(code) {
    if (!code) return '—';
    if (code.startsWith('Key')) return code.replace('Key', '');
    if (code.startsWith('Digit')) return code.replace('Digit', '');
    switch (code) {
      case 'Space': return 'Space';
      case 'ShiftLeft':
      case 'ShiftRight':
        return 'Shift';
      case 'ControlLeft':
      case 'ControlRight':
        return 'Ctrl';
      case 'AltLeft':
      case 'AltRight':
        return 'Alt';
      case 'ArrowLeft': return '←';
      case 'ArrowRight': return '→';
      case 'ArrowUp': return '↑';
      case 'ArrowDown': return '↓';
      default: return code;
    }
  }
  beginListening(actionId) {
    if (this.waitingAction) {
      this.endListening();
    }
    this.waitingAction = actionId;
    const entry = this.rows.get(actionId);
    if (entry) {
      entry.row.classList.add('listening');
      entry.btn.textContent = this.locale.t('settings.waiting');
    }
  }
  endListening() {
    if (!this.waitingAction) return;
    const entry = this.rows.get(this.waitingAction);
    if (entry) {
      entry.row.classList.remove('listening');
      entry.btn.textContent = this.formatKey(this.store.getKeyForAction(this.waitingAction));
    }
    this.waitingAction = null;
  }
  handleKeydown(event) {
    if (!this.waitingAction) return;
    event.preventDefault();
    if (event.code === 'Escape') {
      this.endListening();
      return;
    }
    this.store.setBinding(this.waitingAction, event.code);
    const entry = this.rows.get(this.waitingAction);
    if (entry) {
      entry.btn.textContent = this.formatKey(event.code);
    }
    if (typeof this.onChange === 'function') {
      this.onChange();
    }
    this.endListening();
  }
  refresh() {
    const bindings = this.store.getBindings();
    for (const [action, entry] of this.rows.entries()) {
      entry.btn.textContent = this.formatKey(bindings[action]);
    }
  }
}

const CONFIG = {
  boardWidth: 10,
  boardHeight: 20,
  hiddenRows: 2,
  previewCount: 5,
  gravity: 1.2,
  softDropSpeed: 20,
  lockDelay: 0.5,
  are: 0.04,
  lineClearAre: 0.25,
  das: 0.13,
  arr: 0.03
};

const SPAWN_POS = { default: { x: 3, y: 0 }, I: { x: 3, y: -1 }, O: { x: 4, y: 0 } };
const BAG = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
const COLORS = {
  I: '#5dd9ff',
  J: '#4f6bff',
  L: '#ff9458',
  O: '#ffd952',
  S: '#66ff99',
  T: '#c08cff',
  Z: '#ff5f7a',
  ghost: 'rgba(255,255,255,0.08)'
};
const TETROMINO_SHAPES = {
  T: [
    [[0, 1], [1, 0], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 1]],
    [[0, 1], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 0], [1, 1], [1, 2]]
  ],
  J: [
    [[0, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [2, 2]],
    [[1, 0], [1, 1], [0, 2], [1, 2]]
  ],
  L: [
    [[2, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 2]],
    [[0, 1], [1, 1], [2, 1], [0, 2]],
    [[0, 0], [1, 0], [1, 1], [1, 2]]
  ],
  S: [
    [[1, 0], [2, 0], [0, 1], [1, 1]],
    [[1, 0], [1, 1], [2, 1], [2, 2]],
    [[1, 1], [2, 1], [0, 2], [1, 2]],
    [[0, 0], [0, 1], [1, 1], [1, 2]]
  ],
  Z: [
    [[0, 0], [1, 0], [1, 1], [2, 1]],
    [[2, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [1, 2], [2, 2]],
    [[1, 0], [0, 1], [1, 1], [0, 2]]
  ],
  I: [
    [[0, 1], [1, 1], [2, 1], [3, 1]],
    [[2, 0], [2, 1], [2, 2], [2, 3]],
    [[0, 2], [1, 2], [2, 2], [3, 2]],
    [[1, 0], [1, 1], [1, 2], [1, 3]]
  ],
  O: [
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]]
  ]
};
const SRS_KICKS = {
  JLSTZ: {
    0: { 1: [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], 3: [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]] },
    1: { 0: [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], 2: [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]] },
    2: { 1: [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], 3: [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]] },
    3: { 0: [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], 2: [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]] }
  },
  I: {
    0: { 1: [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], 3: [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]] },
    1: { 0: [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], 2: [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]] },
    2: { 1: [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], 3: [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]] },
    3: { 0: [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], 2: [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]] }
  },
  O: {
    0: { 1: [[0, 0]], 2: [[0, 0]], 3: [[0, 0]] },
    1: { 0: [[0, 0]], 2: [[0, 0]], 3: [[0, 0]] },
    2: { 0: [[0, 0]], 1: [[0, 0]], 3: [[0, 0]] },
    3: { 0: [[0, 0]], 1: [[0, 0]], 2: [[0, 0]] }
  }
};
const SRS_180 = {
  JLSTZ: [
    [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]],
    [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]],
    [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]],
    [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]
  ],
  I: [
    [[0, 0], [1, 0], [-1, 0], [2, 0], [-2, 0], [0, 1], [0, -1]],
    [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0], [2, 0], [-2, 0]],
    [[0, 0], [1, 0], [-1, 0], [2, 0], [-2, 0], [0, 1], [0, -1]],
    [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0], [2, 0], [-2, 0]]
  ],
  O: [
    [[0, 0]],
    [[0, 0]],
    [[0, 0]],
    [[0, 0]]
  ]
};
const COMBO_ATTACK = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5];

class Tetromino {
  constructor(type) {
    this.type = type;
    this.rotation = 0;
    const spawn = SPAWN_POS[type] || SPAWN_POS.default;
    this.x = spawn.x;
    this.y = spawn.y;
    this.spinState = null;
  }
  clone() {
    const t = new Tetromino(this.type);
    t.rotation = this.rotation;
    t.x = this.x;
    t.y = this.y;
    t.spinState = this.spinState ? { ...this.spinState } : null;
    return t;
  }
  cells(rot = this.rotation, x = this.x, y = this.y) {
    return TETROMINO_SHAPES[this.type][rot].map(([dx, dy]) => ({ x: x + dx, y: y + dy }));
  }
}
class Board {
  constructor(width, height, hidden) {
    this.width = width;
    this.visibleHeight = height;
    this.hidden = hidden;
    this.height = height + hidden;
    this.reset();
  }
  reset() {
    this.grid = Array.from({ length: this.height }, () => Array(this.width).fill(null));
  }
  isInside(x, y) {
    return x >= 0 && x < this.width && y >= 0 && y < this.height;
  }
  isEmpty(x, y) {
    if (y < 0) return true;
    if (!this.isInside(x, y)) return false;
    return this.grid[y][x] === null;
  }
  isValid(piece, x = piece.x, y = piece.y, rot = piece.rotation) {
    return piece.cells(rot, x, y).every(cell => cell.x >= 0 && cell.x < this.width && cell.y < this.height && this.isEmpty(cell.x, cell.y));
  }
  place(piece) {
    for (const cell of piece.cells()) {
      if (cell.y >= 0 && cell.y < this.height) this.grid[cell.y][cell.x] = piece.type;
    }
  }
  clearLines() {
    let cleared = 0;
    for (let y = this.height - 1; y >= 0; y--) {
      if (this.grid[y].every(v => v)) {
        this.grid.splice(y, 1);
        this.grid.unshift(Array(this.width).fill(null));
        cleared++;
        y++;
      }
    }
    const perfectClear = cleared > 0 && this.grid.every(row => row.every(v => !v));
    return { lines: cleared, perfectClear };
  }
  getVisible() {
    return this.grid.slice(this.hidden);
  }
}

class StatsTracker {
  constructor() {
    this.reset();
  }
  reset() {
    this.lines = 0;
    this.attack = 0;
    this.pieces = 0;
    this.elapsed = 0;
    this.running = false;
  }
  start() {
    this.elapsed = 0;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  update(dt) {
    if (this.running) this.elapsed += dt;
  }
  addLines(n) {
    this.lines += n;
  }
  addAttack(n) {
    this.attack += n;
  }
  addPiece() {
    this.pieces++;
  }
  snapshot() {
    const seconds = this.elapsed;
    const minutes = seconds / 60;
    return {
      lines: this.lines,
      time: seconds,
      attack: this.attack,
      pieces: this.pieces,
      apm: seconds > 0 ? this.attack / minutes : 0,
      pps: seconds > 0 ? this.pieces / seconds : 0
    };
  }
}

class Game {
  constructor(config) {
    this.config = config;
    this.board = new Board(config.boardWidth, config.boardHeight, config.hiddenRows);
    this.stats = new StatsTracker();
    this.callbacks = {};
    this.random = Math.random.bind(Math);
    this.reset();
  }
  reset() {
    this.state = 'idle';
    this.queue = [];
    this.holdPiece = null;
    this.holdUsed = false;
    this.active = null;
    this.fallAcc = 0;
    this.lockTimer = 0;
    this.softDrop = false;
    this.areTimer = 0;
    this.combo = -1;
    this.lastClear = null;
  }
  setCallbacks(cb) {
    this.callbacks = cb || {};
  }
  start() {
    this.reset();
    this.stats.reset();
    this.stats.start();
    this.board.reset();
    this.state = 'running';
    this.ensureQueue();
    this.spawnNext();
    if (this.callbacks.state) this.callbacks.state(this.state);
  }
  update(dt) {
    if (this.state !== 'running') return;
    this.stats.update(dt);
    if (this.areTimer > 0) {
      this.areTimer -= dt;
      if (this.areTimer <= 0) this.spawnNext();
      return;
    }
    if (!this.active) return;
    const speed = this.softDrop ? this.config.softDropSpeed : this.config.gravity;
    this.fallAcc += speed * dt;
    while (this.fallAcc >= 1) {
      if (this.tryFall()) this.fallAcc -= 1;
      else {
        this.fallAcc = 0;
        break;
      }
    }
    if (this.active && !this.canFall()) {
      this.lockTimer += dt;
      if (this.lockTimer >= this.config.lockDelay) this.lockPiece();
    } else {
      this.lockTimer = 0;
    }
  }
  ensureQueue() {
    while (this.queue.length < this.config.previewCount + 1) {
      this.queue.push(...this.makeBag());
    }
  }
  makeBag() {
    const bag = [...BAG];
    for (let i = bag.length - 1; i > 0; i--) {
      const j = Math.floor(this.random() * (i + 1));
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
    return bag;
  }
  takeFromQueue() {
    this.ensureQueue();
    return this.queue.shift();
  }
  createPiece(type) {
    const piece = new Tetromino(type);
    piece.rotation = 0;
    piece.spinState = null;
    return piece;
  }
  spawnNext() {
    const type = this.takeFromQueue();
    const piece = this.createPiece(type);
    if (!this.board.isValid(piece)) {
      this.finish();
      return;
    }
    this.active = piece;
    this.fallAcc = 0;
    this.lockTimer = 0;
    this.ensureQueue();
  }
  hold() {
    if (this.state !== 'running' || !this.active || this.holdUsed) return;
    const current = this.active.type;
    if (this.holdPiece) {
      const nextType = this.holdPiece;
      this.holdPiece = current;
      const piece = this.createPiece(nextType);
      if (!this.board.isValid(piece)) {
        this.finish();
        return;
      }
      this.active = piece;
    } else {
      this.holdPiece = current;
      this.active = null;
      this.spawnNext();
    }
    this.holdUsed = true;
    this.softDrop = false;
    this.fallAcc = 0;
    this.lockTimer = 0;
  }
  hardDrop() {
    if (this.state !== 'running' || !this.active) return;
    while (this.board.isValid(this.active, this.active.x, this.active.y + 1)) {
      this.active.y++;
    }
    this.lockPiece();
  }
  move(dir) {
    if (this.state !== 'running' || !this.active) return false;
    const nx = this.active.x + dir;
    if (!this.board.isValid(this.active, nx, this.active.y)) return false;
    this.active.x = nx;
    this.resetSpin();
    this.lockTimer = 0;
    return true;
  }
  tryFall() {
    if (!this.active) return false;
    const ny = this.active.y + 1;
    if (this.board.isValid(this.active, this.active.x, ny)) {
      this.active.y = ny;
      this.resetSpin();
      return true;
    }
    return false;
  }
  canFall() {
    return this.active && this.board.isValid(this.active, this.active.x, this.active.y + 1);
  }
  rotate(dir) {
    if (this.state !== 'running' || !this.active) return;
    const delta = dir === 'ccw' ? -1 : dir === 'cw' ? 1 : 2;
    const from = this.active.rotation;
    const to = (from + delta + 4) % 4;
    const kicks = this.getKicks(this.active.type, from, to, dir);
    for (let i = 0; i < kicks.length; i++) {
      const [dx, dy] = kicks[i];
      if (this.board.isValid(this.active, this.active.x + dx, this.active.y + dy, to)) {
        this.active.x += dx;
        this.active.y += dy;
        this.active.rotation = to;
        this.active.spinState = { used: true, kick: i, type: dir };
        this.lockTimer = 0;
        return true;
      }
    }
    return false;
  }
  resetSpin() {
    if (this.active) this.active.spinState = null;
  }
  getKicks(type, from, to, dir) {
    if (dir === '180') {
      const group = type === 'I' ? SRS_180.I : type === 'O' ? SRS_180.O : SRS_180.JLSTZ;
      return group[from];
    }
    const table = type === 'I' ? SRS_KICKS.I : type === 'O' ? SRS_KICKS.O : SRS_KICKS.JLSTZ;
    return (table[from] && table[from][to]) || [[0, 0]];
  }
  lockPiece() {
    if (!this.active) return;
    this.board.place(this.active);
    const spinResult = this.evaluateSpin(this.active);
    const clear = this.board.clearLines();
    const lines = clear.lines;
    const perfectClear = clear.perfectClear;
    this.stats.addPiece();
    let attack = 0;
    if (lines > 0) {
      this.combo += 1;
      this.stats.addLines(lines);
      attack += this.computeAttack(lines, spinResult, perfectClear);
    } else {
      this.combo = -1;
    }
    if (attack > 0) this.stats.addAttack(attack);
    this.lastClear = { lines, spin: spinResult, perfectClear, attack };
    this.active = null;
    this.holdUsed = false;
    this.lockTimer = 0;
    this.fallAcc = 0;
    this.softDrop = false;
    this.areTimer = lines > 0 ? this.config.lineClearAre : this.config.are;
    if (this.stats.lines >= 40) {
      this.finish();
    }
  }
  computeAttack(lines, spinResult, perfectClear) {
    let attack = 0;
    const comboIndex = Math.max(0, this.combo);
    const comboBonus = comboIndex < COMBO_ATTACK.length ? COMBO_ATTACK[comboIndex] : COMBO_ATTACK[COMBO_ATTACK.length - 1];
    const spinType = spinResult.type === 'mini' && lines >= 2 ? 't' : spinResult.type;
    switch (spinType) {
      case 't':
        if (lines === 1) attack += 2;
        else if (lines === 2) attack += 4;
        else if (lines === 3) attack += 6;
        break;
      case 'mini':
        if (lines === 1) attack += 1;
        break;
      default:
        if (lines === 2) attack += 1;
        else if (lines === 3) attack += 2;
        else if (lines === 4) attack += 4;
        break;
    }
    attack += comboBonus;
    if (perfectClear) attack += 10;
    return attack;
  }
  evaluateSpin(piece) {
    if (piece.type !== 'T' || !piece.spinState || !piece.spinState.used) return { type: 'none' };
    const center = { x: piece.x + 1, y: piece.y + 1 };
    const corners = [
      { x: center.x - 1, y: center.y - 1 },
      { x: center.x + 1, y: center.y - 1 },
      { x: center.x - 1, y: center.y + 1 },
      { x: center.x + 1, y: center.y + 1 }
    ];
    let filled = 0;
    for (const corner of corners) {
      if (!this.board.isEmpty(corner.x, corner.y)) filled++;
    }
    if (filled < 3) return { type: 'none' };
    let mini = false;
    if (piece.spinState.type !== '180') {
      mini = filled === 3 && piece.spinState.kick >= 3;
    }
    return mini ? { type: 'mini' } : { type: 't' };
  }
  setSoftDrop(active) {
    if (this.state !== 'running') return;
    this.softDrop = active;
  }
  finish() {
    if (this.state === 'finished') return;
    this.state = 'finished';
    this.active = null;
    this.areTimer = 0;
    this.softDrop = false;
    this.stats.stop();
    if (this.callbacks.finish) this.callbacks.finish(this.getSummary());
  }
  getSummary() {
    const snap = this.stats.snapshot();
    return { time: snap.time, apm: snap.apm, pps: snap.pps, lines: snap.lines };
  }
  getRenderState() {
    const grid = this.board.getVisible();
    const active = this.active ? this.active.clone() : null;
    const ghost = active ? this.ghostCells(active) : null;
    return {
      grid,
      active,
      ghost,
      hold: this.holdPiece,
      queue: this.queue.slice(0, this.config.previewCount),
      stats: this.stats.snapshot(),
      state: this.state,
      hidden: this.board.hidden
    };
  }
  ghostCells(piece) {
    const shadow = piece.clone();
    while (this.board.isValid(shadow, shadow.x, shadow.y + 1)) shadow.y++;
    return shadow.cells();
  }
}
class Renderer {
  constructor(elements) {
    this.boardCtx = elements.board.getContext('2d');
    this.holdCtx = elements.hold.getContext('2d');
    this.nextCtx = elements.next.getContext('2d');
    this.hud = elements.hud;
    this.config = elements.config;
    this.blockSize = Math.floor(elements.board.width / this.config.boardWidth);
  }
  render(game) {
    const state = game.getRenderState();
    this.drawBoard(state);
    this.drawHold(state.hold);
    this.drawNext(state.queue);
    this.updateHud(state.stats);
  }
  drawBoard(state) {
    const ctx = this.boardCtx;
    const cell = this.blockSize;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.fillStyle = '#0b1324';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    for (let y = 0; y < this.config.boardHeight; y++) {
      for (let x = 0; x < this.config.boardWidth; x++) {
        ctx.strokeRect(x * cell, y * cell, cell, cell);
      }
    }
    const drawCells = (cells, color, alpha = 1) => {
      ctx.fillStyle = color;
      ctx.globalAlpha = alpha;
      for (const c of cells) {
        const vy = c.y - state.hidden;
        if (vy < 0 || vy >= this.config.boardHeight) continue;
        ctx.fillRect(c.x * cell, vy * cell, cell, cell);
      }
      ctx.globalAlpha = 1;
    };
    for (let y = 0; y < state.grid.length; y++) {
      for (let x = 0; x < state.grid[y].length; x++) {
        const type = state.grid[y][x];
        if (type) {
          ctx.fillStyle = COLORS[type];
          ctx.fillRect(x * cell, y * cell, cell, cell);
        }
      }
    }
    if (state.ghost) drawCells(state.ghost, COLORS.ghost, 1);
    if (state.active) drawCells(state.active.cells(), COLORS[state.active.type]);
  }
  drawHold(type) {
    const ctx = this.holdCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (!type) return;
    ctx.save();
    this.drawMini(ctx, type, ctx.canvas.width, ctx.canvas.height);
    ctx.restore();
  }
  drawNext(queue) {
    const ctx = this.nextCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    queue.forEach((type, index) => {
      ctx.save();
      ctx.translate(0, index * 80);
      this.drawMini(ctx, type, ctx.canvas.width, 80);
      ctx.restore();
    });
  }
  drawMini(ctx, type, boxWidth = ctx.canvas.width, boxHeight = ctx.canvas.height) {
    const size = 28;
    const shape = TETROMINO_SHAPES[type][0];
    const minX = Math.min(...shape.map(c => c[0]));
    const maxX = Math.max(...shape.map(c => c[0]));
    const minY = Math.min(...shape.map(c => c[1]));
    const maxY = Math.max(...shape.map(c => c[1]));
    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    const offsetX = (boxWidth - width * size) / 2;
    const offsetY = (boxHeight - height * size) / 2;
    ctx.fillStyle = COLORS[type];
    for (const [dx, dy] of shape) {
      ctx.fillRect(offsetX + (dx - minX) * size, offsetY + (dy - minY) * size, size - 2, size - 2);
    }
  }
  updateHud(stats) {
    const { lines, time, apm, pps } = stats;
    this.hud.lines.textContent = lines;
    this.hud.time.textContent = formatTime(time);
    this.hud.apm.textContent = apm.toFixed(2);
    this.hud.pps.textContent = pps.toFixed(2);
  }
}

class InputManager {
  constructor(game, settingsStore) {
    this.game = game;
    this.config = game.config;
    this.store = settingsStore;
    this.bindings = {};
    this.left = false;
    this.right = false;
    this.lastDir = 0;
    this.dasTimer = 0;
    this.arrTimer = 0;
    this.softDrop = false;
    this.refreshBindings();
    window.addEventListener('keydown', (e) => this.onKeyDown(e));
    window.addEventListener('keyup', (e) => this.onKeyUp(e));
  }
  refreshBindings() {
    const bindings = this.store.getBindings();
    this.bindingsByKey = {};
    Object.entries(bindings).forEach(([action, code]) => {
      if (code) this.bindingsByKey[code] = action;
    });
  }
  onKeyDown(e) {
    const action = this.bindingsByKey[e.code];
    if (!action) return;
    e.preventDefault();
    switch (action) {
      case 'moveLeft':
        if (e.repeat) return;
        this.left = true;
        this.lastDir = -1;
        this.dasTimer = 0;
        this.arrTimer = 0;
        this.game.move(-1);
        break;
      case 'moveRight':
        if (e.repeat) return;
        this.right = true;
        this.lastDir = 1;
        this.dasTimer = 0;
        this.arrTimer = 0;
        this.game.move(1);
        break;
      case 'softDrop':
        this.softDrop = true;
        this.game.setSoftDrop(true);
        break;
      case 'hardDrop':
        if (e.repeat) return;
        this.game.hardDrop();
        break;
      case 'rotateCW':
        if (e.repeat) return;
        this.game.rotate('cw');
        break;
      case 'rotateCCW':
        if (e.repeat) return;
        this.game.rotate('ccw');
        break;
      case 'rotate180':
        if (e.repeat) return;
        this.game.rotate('180');
        break;
      case 'hold':
        if (e.repeat) return;
        this.game.hold();
        break;
      default:
        break;
    }
  }
  onKeyUp(e) {
    const action = this.bindingsByKey[e.code];
    if (!action) return;
    switch (action) {
      case 'moveLeft':
        this.left = false;
        this.dasTimer = 0;
        this.arrTimer = 0;
        break;
      case 'moveRight':
        this.right = false;
        this.dasTimer = 0;
        this.arrTimer = 0;
        break;
      case 'softDrop':
        this.softDrop = false;
        this.game.setSoftDrop(false);
        break;
      default:
        break;
    }
  }
  update(dt) {
    this.game.setSoftDrop(this.softDrop);
    const dir = this.getHorizontalDir();
    if (dir === 0) {
      this.dasTimer = 0;
      this.arrTimer = 0;
      return;
    }
    this.dasTimer += dt;
    if (this.dasTimer < this.config.das) return;
    if (this.config.arr === 0) {
      this.game.move(dir);
      return;
    }
    this.arrTimer += dt;
    while (this.arrTimer >= this.config.arr) {
      if (!this.game.move(dir)) {
        this.arrTimer = 0;
        break;
      }
      this.arrTimer -= this.config.arr;
    }
  }
  getHorizontalDir() {
    if (this.left && this.right) return this.lastDir;
    if (this.left) return -1;
    if (this.right) return 1;
    return 0;
  }
}

function formatTime(seconds) {
  const total = Math.max(0, seconds);
  const minutes = Math.floor(total / 60);
  const secs = total - minutes * 60;
  const whole = Math.floor(secs);
  const cent = Math.floor((secs - whole) * 100);
  return `${String(minutes).padStart(2, '0')}:${String(whole).padStart(2, '0')}.${String(cent).padStart(2, '0')}`;
}
class App {
  constructor() {
    this.locale = new Localization(i18n, 'ru');
    this.settingsStore = new SettingsStore('ru-tetris-binds', DEFAULT_BINDINGS);
    this.screenManager = new ScreenManager();
    this.game = new Game(CONFIG);
    const hud = {
      lines: document.getElementById('linesVal'),
      time: document.getElementById('timeVal'),
      apm: document.getElementById('apmVal'),
      pps: document.getElementById('ppsVal')
    };
    this.renderer = new Renderer({
      board: document.getElementById('boardCanvas'),
      hold: document.getElementById('holdCanvas'),
      next: document.getElementById('nextCanvas'),
      hud,
      config: CONFIG
    });
    this.input = new InputManager(this.game, this.settingsStore);
    this.settingsUI = new SettingsUI(
      document.getElementById('settingsList'),
      this.settingsStore,
      this.locale,
      () => this.input.refreshBindings()
    );
    this.bindUI();
    this.game.setCallbacks({
      finish: (summary) => this.showResults(summary)
    });
    this.lastFrame = performance.now();
    requestAnimationFrame((ts) => this.loop(ts));
  }
  bindUI() {
    const menuPlayBtn = document.getElementById('menuPlayBtn');
    const menuMatchBtn = document.getElementById('menuMatchBtn');
    const menuSettingsBtn = document.getElementById('menuSettingsBtn');
    const menuLoginBtn = document.getElementById('menuLoginBtn');
    const gameBackBtn = document.getElementById('gameBackBtn');
    const settingsBackBtn = document.getElementById('settingsBackBtn');
    const matchBackBtn = document.getElementById('matchBackBtn');
    const loginBackBtn = document.getElementById('loginBackBtn');
    const menuHint = document.getElementById('menuHint');

    menuPlayBtn.textContent = this.locale.t('menu.play40');
    menuMatchBtn.textContent = this.locale.t('menu.matchmaking');
    menuSettingsBtn.textContent = this.locale.t('menu.settings');
    menuLoginBtn.textContent = this.locale.t('menu.login');
    menuHint.textContent = this.locale.t('menu.hint');

    document.getElementById('settingsTitle').textContent = this.locale.t('settings.title');
    document.getElementById('settingsHint').textContent = this.locale.t('settings.hint');
    settingsBackBtn.textContent = this.locale.t('match.back');

    document.getElementById('matchTitle').textContent = this.locale.t('match.title');
    document.getElementById('matchDescription').textContent = this.locale.t('match.description');
    matchBackBtn.textContent = this.locale.t('match.back');

    document.getElementById('loginTitle').textContent = this.locale.t('login.title');
    document.getElementById('loginDescription').textContent = this.locale.t('login.description');
    loginBackBtn.textContent = this.locale.t('login.back');

    gameBackBtn.textContent = this.locale.t('game.back');

    menuPlayBtn.addEventListener('click', () => this.startFortyLines());
    menuMatchBtn.addEventListener('click', () => this.openScreen('matchScreen'));
    menuSettingsBtn.addEventListener('click', () => {
      this.settingsUI.refresh();
      this.openScreen('settingsScreen');
    });
    menuLoginBtn.addEventListener('click', () => this.openScreen('loginScreen'));

    settingsBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));
    matchBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));
    loginBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));
    gameBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));

    document.getElementById('resultMenuBtn').textContent = this.locale.t('result.toMenu');
    document.getElementById('resultTitle').textContent = this.locale.t('result.title');
    document.getElementById('resultMenuBtn').addEventListener('click', () => {
      this.hideOverlay();
      this.openScreen('mainMenu');
    });
  }
  openScreen(id) {
    const element = document.getElementById(id);
    this.screenManager.show(element);
    if (id !== 'gameScreen' && this.game.state === 'running') {
      this.game.finish();
      this.hideOverlay();
    }
    if (id === 'gameScreen' && this.game.state !== 'running') {
      this.hideOverlay();
      this.game.start();
    }
  }
  startFortyLines() {
    this.openScreen('gameScreen');
  }
  showResults(summary) {
    const overlay = document.getElementById('resultOverlay');
    const resultStats = document.getElementById('resultStats');
    resultStats.innerHTML = `LINES: ${summary.lines}<br>TIME: ${formatTime(summary.time)}<br>APM: ${summary.apm.toFixed(2)}<br>PPS: ${summary.pps.toFixed(2)}`;
    overlay.classList.remove('hidden');
  }
  hideOverlay() {
    document.getElementById('resultOverlay').classList.add('hidden');
  }
  loop(timestamp) {
    const dt = (timestamp - this.lastFrame) / 1000;
    this.lastFrame = timestamp;
    this.input.update(dt);
    this.game.update(dt);
    this.renderer.render(this.game);
    requestAnimationFrame((ts) => this.loop(ts));
  }
}

new App();
})();
</script>
</body>
</html>
