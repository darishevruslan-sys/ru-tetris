<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>RU Tetris Sprint 40L</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#05070f;color:#e4e7ff;font-family:"Segoe UI",sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;padding:24px}
button{background:#1b2440;color:#f8f9ff;border:none;padding:12px 24px;border-radius:8px;font-size:16px;cursor:pointer;transition:background .2s;font-weight:600}
button:hover{background:#27335d}
.app{width:100%;max-width:1080px;display:flex;flex-direction:column;gap:24px}
.screen{display:none;flex-direction:column;align-items:center;gap:24px}
.screen.active{display:flex}
.logo{font-size:36px;letter-spacing:6px;text-transform:uppercase;color:#9aa4d9;text-align:center}
.menu-buttons{display:flex;flex-direction:column;gap:16px;width:100%;max-width:320px}
.menu-buttons button{width:100%}
.info-card{background:#0b1020;border-radius:12px;padding:24px;text-align:center;color:#9aa4d9;max-width:420px;line-height:1.5}
.top-bar{display:flex;gap:20px;align-items:center;width:100%;justify-content:space-between}
.top-actions{display:flex;gap:12px;align-items:center}
.stats{display:grid;grid-template-columns:repeat(2,auto);gap:6px 20px;font-size:14px}
.hud-text{color:#aab4dd}
.playfield{display:flex;gap:16px;align-items:flex-start;width:100%;justify-content:center}
.panel{background:#0b1020;border-radius:12px;padding:16px;display:flex;flex-direction:column;align-items:center;gap:12px;min-width:140px}
.panel-title{font-size:14px;letter-spacing:2px;color:#8a94c9}
canvas{background:#0f1628;border-radius:10px}
#boardCanvas{border:2px solid #1d2745}
.overlay{position:fixed;inset:0;background:rgba(5,7,15,.92);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;font-size:18px;text-align:center;z-index:10}
.overlay.hidden{display:none}
.overlay .title{font-size:28px;letter-spacing:4px}
.overlay button{font-size:18px}
.settings-list{width:100%;max-width:520px;display:flex;flex-direction:column;gap:12px}
.settings-row{display:flex;align-items:center;justify-content:space-between;background:#0b1020;padding:16px;border-radius:10px}
.settings-row.listening{outline:2px solid #5dd9ff}
.settings-row .action-label{font-size:16px}
.settings-row button{min-width:160px}
.helper-text{color:#7c86b9;font-size:14px;text-align:center;line-height:1.5}
.placeholder-card{background:#0b1020;padding:24px;border-radius:12px;color:#9aa4d9;text-align:center;max-width:420px;line-height:1.6}
.match-card{background:#0b1020;padding:24px;border-radius:12px;color:#c7cff6;display:flex;flex-direction:column;gap:20px;width:100%;max-width:720px}
.match-form{display:flex;flex-direction:column;gap:12px}
.match-form-row{display:flex;gap:12px;flex-wrap:wrap}
.match-input{flex:1;min-width:180px;padding:12px 16px;border-radius:8px;border:1px solid #1d2745;background:#050a18;color:#e4e7ff;font-size:16px}
.match-status{color:#7c86b9;font-size:14px;line-height:1.4}
.match-room-code{font-size:16px;color:#9aa4d9}
.match-boards{display:flex;gap:24px;justify-content:center;flex-wrap:wrap}
.match-boards.hidden{display:none}
.match-board{display:flex;flex-direction:column;gap:10px;align-items:center}
.match-board canvas{border:2px solid #1d2745;background:#0f1628;border-radius:10px}
.match-stats{font-size:14px;color:#7c86b9;text-align:center;min-height:32px}
input::placeholder{color:#4f5a8c}
</style>
</head>
<body>
<div class="app">
  <div id="mainMenu" class="screen active">
    <div class="logo">RU Tetris</div>
    <div class="menu-buttons">
      <button id="menuPlayBtn"></button>
      <button id="menuMatchBtn"></button>
      <button id="menuSettingsBtn"></button>
      <button id="menuLoginBtn"></button>
    </div>
    <div class="info-card" id="menuHint"></div>
  </div>

  <div id="gameScreen" class="screen">
    <div class="top-bar">
      <div class="top-actions">
        <button id="gameBackBtn"></button>
      </div>
      <div class="stats">
        <div>LINES</div><div class="hud-text" id="linesVal">0</div>
        <div>TIME</div><div class="hud-text" id="timeVal">00:00.00</div>
        <div>APM</div><div class="hud-text" id="apmVal">0.00</div>
        <div>PPS</div><div class="hud-text" id="ppsVal">0.00</div>
      </div>
    </div>
    <div class="playfield">
      <div class="panel">
        <div class="panel-title">HOLD</div>
        <canvas id="holdCanvas" width="140" height="140"></canvas>
      </div>
      <canvas id="boardCanvas" width="280" height="616"></canvas>
      <div class="panel">
        <div class="panel-title">NEXT</div>
        <canvas id="nextCanvas" width="140" height="420"></canvas>
      </div>
    </div>
  </div>

  <div id="settingsScreen" class="screen">
    <div class="logo" id="settingsTitle"></div>
    <div class="helper-text" id="settingsHint"></div>
    <div class="settings-list" id="settingsList"></div>
    <div class="top-actions">
      <button id="settingsBackBtn"></button>
    </div>
  </div>

  <div id="matchScreen" class="screen">
    <div class="logo" id="matchTitle"></div>
    <div class="match-card">
      <div class="match-form" id="matchSetup">
        <div class="match-status" id="matchDescription"></div>
        <div class="match-form-row">
          <input id="roomCodeInput" class="match-input" type="text" maxlength="8">
          <button id="joinRoomBtn"></button>
        </div>
        <div class="match-form-row">
          <button id="createRoomBtn"></button>
          <div class="match-room-code" id="matchRoomCode"></div>
        </div>
      </div>
      <div class="match-boards hidden" id="matchBoards">
        <div class="match-board">
          <div class="panel-title" id="localBoardTitle"></div>
          <canvas id="localMatchBoard" width="200" height="440"></canvas>
          <div class="match-stats" id="localBoardStats"></div>
        </div>
        <div class="match-board">
          <div class="panel-title" id="remoteBoardTitle"></div>
          <canvas id="remoteMatchBoard" width="200" height="440"></canvas>
          <div class="match-stats" id="remoteBoardStats"></div>
        </div>
      </div>
    </div>
    <button id="matchBackBtn"></button>
  </div>

  <div id="loginScreen" class="screen">
    <div class="logo" id="loginTitle"></div>
    <div class="placeholder-card" id="loginDescription"></div>
    <button id="loginBackBtn"></button>
  </div>
</div>

<div id="resultOverlay" class="overlay hidden">
  <div class="title" id="resultTitle"></div>
  <div id="resultStats"></div>
  <button id="resultMenuBtn"></button>
</div>

<script>
(() => {
const i18n = {
  ru: {
    menu: {
      play40: 'Играть (40 линий)',
      matchmaking: 'Онлайн матчмейкинг',
      settings: 'Настройки управления',
      login: 'Войти',
      hint: 'Соревнуйтесь с собой и улучшайте время прохождения спринта на 40 линий.'
    },
    game: {
      back: 'В меню'
    },
    settings: {
      title: 'Настройки управления',
      hint: 'Нажмите на действие и затем нажмите желаемую клавишу. Настройки сохраняются автоматически.',
      waiting: 'Ожидание ввода...'
    },
    match: {
      title: 'Онлайн матчмейкинг',
      description: 'Введите код комнаты или создайте новую, чтобы начать матч.',
      back: 'Назад',
      join: 'Войти',
      create: 'Создать комнату',
      placeholder: 'Например, ABC123',
      statusIdle: 'Введите код комнаты или создайте новую.',
      statusNeedCode: 'Введите код комнаты, чтобы подключиться.',
      statusConnecting: 'Подключение...',
      statusError: 'Не удалось подключиться. Попробуйте ещё раз.',
      createSuccess: 'Комната {{code}} создана. Поделитесь кодом с другом.',
      joinSuccess: 'Вы присоединились к комнате {{code}}.',
      localPlayer: 'Вы',
      remotePlayer: 'Оппонент',
      waitingOpponent: 'Ожидание данных от оппонента...'
    },
    login: {
      title: 'Войти',
      description: 'Авторизация появится позже. Следите за обновлениями!',
      back: 'Назад'
    },
    result: {
      title: '40 линий завершены!',
      toMenu: 'В меню'
    },
    actions: {
      moveLeft: 'Влево',
      moveRight: 'Вправо',
      softDrop: 'Soft drop',
      hardDrop: 'Hard drop',
      rotateCW: 'Поворот CW',
      rotateCCW: 'Поворот CCW',
      rotate180: 'Поворот 180°',
      hold: 'Холд'
    }
  },
  en: {
    menu: {
      play40: 'Play (40 Lines)',
      matchmaking: 'Online Matchmaking',
      settings: 'Controls',
      login: 'Sign In',
      hint: 'Race against yourself and improve your 40L sprint time.'
    },
    game: {
      back: 'Main Menu'
    },
    settings: {
      title: 'Controls',
      hint: 'Click an action and press a key. The settings are saved automatically.',
      waiting: 'Listening...'
    },
    match: {
      title: 'Online Matchmaking',
      description: 'Enter a room code or create a new one to start a match.',
      back: 'Back',
      join: 'Join',
      create: 'Create Room',
      placeholder: 'e.g. ABC123',
      statusIdle: 'Enter a room code or create a new one.',
      statusNeedCode: 'Type a room code to connect.',
      statusConnecting: 'Connecting...',
      statusError: 'Connection failed. Please try again.',
      createSuccess: 'Room {{code}} created. Share the code with a friend.',
      joinSuccess: 'Joined room {{code}}.',
      localPlayer: 'You',
      remotePlayer: 'Opponent',
      waitingOpponent: 'Waiting for opponent data...'
    },
    login: {
      title: 'Sign In',
      description: 'Authentication will arrive in a future update. Stay tuned!',
      back: 'Back'
    },
    result: {
      title: '40 Lines Complete!',
      toMenu: 'Main Menu'
    },
    actions: {
      moveLeft: 'Move left',
      moveRight: 'Move right',
      softDrop: 'Soft drop',
      hardDrop: 'Hard drop',
      rotateCW: 'Rotate CW',
      rotateCCW: 'Rotate CCW',
      rotate180: 'Rotate 180°',
      hold: 'Hold'
    }
  }
};

class Localization {
  constructor(dictionary, lang = 'ru') {
    this.dictionary = dictionary;
    this.lang = lang;
  }
  t(path, values = {}) {
    const segments = path.split('.');
    let node = this.dictionary[this.lang];
    for (const segment of segments) {
      if (!node) break;
      node = node[segment];
    }
    if (typeof node === 'string') {
      return node.replace(/\{\{(\w+)\}\}/g, (match, key) => (key in values ? values[key] : match));
    }
    return node ?? path;
  }
}

class SettingsStore {
  constructor(storageKey, defaults) {
    this.storageKey = storageKey;
    this.defaults = defaults;
    this.data = this.load();
  }
  load() {
    try {
      const raw = localStorage.getItem(this.storageKey);
      if (!raw) return { ...this.defaults };
      const parsed = JSON.parse(raw);
      return { ...this.defaults, ...parsed };
    } catch (err) {
      return { ...this.defaults };
    }
  }
  save() {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (err) {
      /* ignore */
    }
  }
  getBindings() {
    return { ...this.data };
  }
  setBinding(action, keyCode) {
    this.data[action] = keyCode;
    this.save();
  }
  getKeyForAction(action) {
    return this.data[action] ?? null;
  }
}

class ScreenManager {
  constructor() {
    this.current = null;
  }
  show(element) {
    if (this.current === element) return;
    if (this.current) this.current.classList.remove('active');
    this.current = element;
    if (this.current) this.current.classList.add('active');
  }
}

const DEFAULT_BINDINGS = {
  moveLeft: 'ArrowLeft',
  moveRight: 'ArrowRight',
  softDrop: 'ArrowDown',
  hardDrop: 'Space',
  rotateCW: 'KeyX',
  rotateCCW: 'KeyZ',
  rotate180: 'KeyA',
  hold: 'ShiftLeft'
};

const ACTIONS = [
  { id: 'moveLeft', icon: '←' },
  { id: 'moveRight', icon: '→' },
  { id: 'rotateCW', icon: '↻' },
  { id: 'rotateCCW', icon: '↺' },
  { id: 'rotate180', icon: '⟳' },
  { id: 'hardDrop', icon: '⭳' },
  { id: 'softDrop', icon: '⭱' },
  { id: 'hold', icon: '⧖' }
];

class SettingsUI {
  constructor(root, store, locale, onChange) {
    this.root = root;
    this.store = store;
    this.locale = locale;
    this.onChange = onChange;
    this.waitingAction = null;
    this.rows = new Map();
    this.build();
    document.addEventListener('keydown', (event) => this.handleKeydown(event));
  }
  build() {
    this.root.innerHTML = '';
    const bindings = this.store.getBindings();
    ACTIONS.forEach(action => {
      const row = document.createElement('div');
      row.className = 'settings-row';
      row.dataset.action = action.id;

      const label = document.createElement('div');
      label.className = 'action-label';
      label.textContent = `${action.icon} ${this.locale.t(`actions.${action.id}`)}`;

      const btn = document.createElement('button');
      btn.textContent = this.formatKey(bindings[action.id]);
      btn.addEventListener('click', () => this.beginListening(action.id));

      row.appendChild(label);
      row.appendChild(btn);
      this.root.appendChild(row);
      this.rows.set(action.id, { row, btn });
    });
  }
  formatKey(code) {
    if (!code) return '—';
    if (code.startsWith('Key')) return code.replace('Key', '');
    if (code.startsWith('Digit')) return code.replace('Digit', '');
    switch (code) {
      case 'Space': return 'Space';
      case 'ShiftLeft':
      case 'ShiftRight':
        return 'Shift';
      case 'ControlLeft':
      case 'ControlRight':
        return 'Ctrl';
      case 'AltLeft':
      case 'AltRight':
        return 'Alt';
      case 'ArrowLeft': return '←';
      case 'ArrowRight': return '→';
      case 'ArrowUp': return '↑';
      case 'ArrowDown': return '↓';
      default: return code;
    }
  }
  beginListening(actionId) {
    if (this.waitingAction) {
      this.endListening();
    }
    this.waitingAction = actionId;
    const entry = this.rows.get(actionId);
    if (entry) {
      entry.row.classList.add('listening');
      entry.btn.textContent = this.locale.t('settings.waiting');
    }
  }
  endListening() {
    if (!this.waitingAction) return;
    const entry = this.rows.get(this.waitingAction);
    if (entry) {
      entry.row.classList.remove('listening');
      entry.btn.textContent = this.formatKey(this.store.getKeyForAction(this.waitingAction));
    }
    this.waitingAction = null;
  }
  handleKeydown(event) {
    if (!this.waitingAction) return;
    event.preventDefault();
    if (event.code === 'Escape') {
      this.endListening();
      return;
    }
    this.store.setBinding(this.waitingAction, event.code);
    const entry = this.rows.get(this.waitingAction);
    if (entry) {
      entry.btn.textContent = this.formatKey(event.code);
    }
    if (typeof this.onChange === 'function') {
      this.onChange();
    }
    this.endListening();
  }
  refresh() {
    const bindings = this.store.getBindings();
    for (const [action, entry] of this.rows.entries()) {
      entry.btn.textContent = this.formatKey(bindings[action]);
    }
  }
}

const CONFIG = {
  boardWidth: 10,
  boardHeight: 20,
  hiddenRows: 2,
  previewCount: 5,
  gravity: 1.2,
  softDropSpeed: 20,
  lockDelay: 0.5,
  are: 0.04,
  lineClearAre: 0.25,
  das: 0.13,
  arr: 0.03
};

const SPAWN_X_STD = 3;
const SPAWN_X_O = SPAWN_X_STD - 1;
const SPAWN_X_I = SPAWN_X_STD + 1;
const SPAWN_Y = -2;
const SPAWN_POS = {
  default: { x: SPAWN_X_STD, y: SPAWN_Y },
  I: { x: SPAWN_X_I, y: SPAWN_Y },
  O: { x: SPAWN_X_O, y: SPAWN_Y }
};
const BAG = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
const COLORS = {
  I: '#5dd9ff',
  J: '#4f6bff',
  L: '#ff9458',
  O: '#ffd952',
  S: '#66ff99',
  T: '#c08cff',
  Z: '#ff5f7a',
  ghost: 'rgba(255,255,255,0.08)'
};
const TETROMINO_SHAPES = {
  T: [
    [[0, 1], [1, 0], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 1]],
    [[0, 1], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 0], [1, 1], [1, 2]]
  ],
  J: [
    [[0, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [2, 2]],
    [[1, 0], [1, 1], [0, 2], [1, 2]]
  ],
  L: [
    [[2, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 2]],
    [[0, 1], [1, 1], [2, 1], [0, 2]],
    [[0, 0], [1, 0], [1, 1], [1, 2]]
  ],
  S: [
    [[1, 0], [2, 0], [0, 1], [1, 1]],
    [[1, 0], [1, 1], [2, 1], [2, 2]],
    [[1, 1], [2, 1], [0, 2], [1, 2]],
    [[0, 0], [0, 1], [1, 1], [1, 2]]
  ],
  Z: [
    [[0, 0], [1, 0], [1, 1], [2, 1]],
    [[2, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [1, 2], [2, 2]],
    [[1, 0], [0, 1], [1, 1], [0, 2]]
  ],
  I: [
    [[0, 1], [1, 1], [2, 1], [3, 1]],
    [[2, 0], [2, 1], [2, 2], [2, 3]],
    [[0, 2], [1, 2], [2, 2], [3, 2]],
    [[1, 0], [1, 1], [1, 2], [1, 3]]
  ],
  O: [
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]]
  ]
};
const JLSTZ_KICKS = {
  '0>1': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
  '1>0': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],

  '1>2': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
  '2>1': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],

  '2>3': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
  '3>2': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],

  '3>0': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
  '0>3': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]]
};

const I_KICKS = {
  '0>1': [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
  '1>0': [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],

  '1>2': [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
  '2>1': [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],

  '2>3': [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
  '3>2': [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],

  '3>0': [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
  '0>3': [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]]
};

const O_KICKS = {
  '0>1': [[0, 0]],
  '1>2': [[0, 0]],
  '2>3': [[0, 0]],
  '3>0': [[0, 0]],
  '1>0': [[0, 0]],
  '2>1': [[0, 0]],
  '3>2': [[0, 0]],
  '0>3': [[0, 0]]
};

function getKickTable(pieceType, fromState, toState) {
  const key = `${fromState}>${toState}`;
  if (pieceType === 'I') {
    return I_KICKS[key] || [[0, 0]];
  }
  if (pieceType === 'O') {
    return O_KICKS[key] || [[0, 0]];
  }
  return JLSTZ_KICKS[key] || [[0, 0]];
}
const COMBO_ATTACK = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5];

class Tetromino {
  constructor(type) {
    this.type = type;
    this.rotationState = 0;
    const spawn = SPAWN_POS[type] || SPAWN_POS.default;
    this.x = spawn.x;
    this.y = spawn.y;
    this.spinState = null;
  }
  clone() {
    const t = new Tetromino(this.type);
    t.rotationState = this.rotationState;
    t.x = this.x;
    t.y = this.y;
    t.spinState = this.spinState ? { ...this.spinState } : null;
    return t;
  }
  getShapeAtRotation(state = this.rotationState) {
    const shapes = TETROMINO_SHAPES[this.type];
    return shapes[state] || shapes[0];
  }
  cells(rot = this.rotationState, x = this.x, y = this.y) {
    const shape = this.getShapeAtRotation(rot);
    return shape.map(([dx, dy]) => ({ x: x + dx, y: y + dy }));
  }
}
class Board {
  constructor(width, height, hidden) {
    this.width = width;
    this.visibleHeight = height;
    this.hidden = hidden;
    this.height = height + hidden;
    this.reset();
  }
  reset() {
    this.grid = Array.from({ length: this.height }, () => Array(this.width).fill(null));
  }
  isInside(x, y) {
    return x >= 0 && x < this.width && y >= 0 && y < this.height;
  }
  isEmpty(x, y) {
    if (y < 0) return true;
    if (!this.isInside(x, y)) return false;
    return this.grid[y][x] === null;
  }
  canPlace(shape, x, y) {
    return shape.every(([dx, dy]) => {
      const nx = x + dx;
      const ny = y + dy;
      return nx >= 0 && nx < this.width && ny < this.height && this.isEmpty(nx, ny);
    });
  }
  isValid(piece, x = piece.x, y = piece.y, rot = piece.rotationState) {
    const shape = piece.getShapeAtRotation(rot);
    return this.canPlace(shape, x, y);
  }
  place(piece) {
    for (const cell of piece.cells()) {
      if (cell.y >= 0 && cell.y < this.height) this.grid[cell.y][cell.x] = piece.type;
    }
  }
  clearLines() {
    let cleared = 0;
    for (let y = this.height - 1; y >= 0; y--) {
      if (this.grid[y].every(v => v)) {
        this.grid.splice(y, 1);
        this.grid.unshift(Array(this.width).fill(null));
        cleared++;
        y++;
      }
    }
    const perfectClear = cleared > 0 && this.grid.every(row => row.every(v => !v));
    return { lines: cleared, perfectClear };
  }
  getSnapshot() {
    return this.grid.map(row => row.slice());
  }
}

class StatsTracker {
  constructor() {
    this.reset();
  }
  reset() {
    this.lines = 0;
    this.attack = 0;
    this.pieces = 0;
    this.elapsed = 0;
    this.running = false;
  }
  start() {
    this.elapsed = 0;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  update(dt) {
    if (this.running) this.elapsed += dt;
  }
  addLines(n) {
    this.lines += n;
  }
  addAttack(n) {
    this.attack += n;
  }
  addPiece() {
    this.pieces++;
  }
  snapshot() {
    const seconds = this.elapsed;
    const minutes = seconds / 60;
    return {
      lines: this.lines,
      time: seconds,
      attack: this.attack,
      pieces: this.pieces,
      apm: seconds > 0 ? this.attack / minutes : 0,
      pps: seconds > 0 ? this.pieces / seconds : 0
    };
  }
}

class MultiplayerClient {
  constructor() {
    this.remoteStateHandler = () => {};
    this.garbageHandler = () => {};
    this.mockTimer = null;
    this.mockConfig = { width: 10, height: 20 };
  }
  configure(config) {
    if (config) {
      this.mockConfig = {
        width: config.boardWidth ?? this.mockConfig.width,
        height: config.boardHeight ?? this.mockConfig.height
      };
    }
  }
  createRoom(code) {
    this.stopMock();
    // TODO: реальная синхронизация состояний через WebSocket
    return new Promise((resolve) => {
      setTimeout(() => {
        this.startMock();
        resolve({ code });
      }, 150);
    });
  }
  joinRoom(code) {
    this.stopMock();
    // TODO: реальная синхронизация состояний через WebSocket
    return new Promise((resolve) => {
      setTimeout(() => {
        this.startMock();
        resolve({ code });
      }, 150);
    });
  }
  sendState(state) {
    // TODO: реальная синхронизация состояний через WebSocket
    this.lastState = state;
  }
  onRemoteState(callback) {
    this.remoteStateHandler = typeof callback === 'function' ? callback : () => {};
  }
  onGarbage(callback) {
    this.garbageHandler = typeof callback === 'function' ? callback : () => {};
  }
  disconnect() {
    this.stopMock();
  }
  startMock() {
    this.stopMock();
    if (typeof this.remoteStateHandler === 'function') {
      this.remoteStateHandler(this.generateMockState());
    }
    this.mockTimer = setInterval(() => {
      if (typeof this.remoteStateHandler === 'function') {
        this.remoteStateHandler(this.generateMockState());
      }
    }, 2000);
  }
  stopMock() {
    if (this.mockTimer) {
      clearInterval(this.mockTimer);
      this.mockTimer = null;
    }
  }
  generateMockState() {
    const width = this.mockConfig.width;
    const height = this.mockConfig.height;
    const matrix = Array.from({ length: height }, () => Array(width).fill(null));
    for (let x = 0; x < width; x++) {
      const columnHeight = Math.floor(Math.random() * Math.min(height, 6));
      for (let y = height - 1; y >= height - columnHeight; y--) {
        matrix[y][x] = BAG[(x + y) % BAG.length];
      }
    }
    const activeType = BAG[Math.floor(Math.random() * BAG.length)];
    const spawn = SPAWN_POS[activeType] || SPAWN_POS.default;
    const activeCells = TETROMINO_SHAPES[activeType][0].map(([dx, dy]) => ({
      x: spawn.x + dx,
      y: spawn.y + dy
    }));
    const time = Math.random() * 120;
    const pieces = Math.floor(time * 1.5);
    const attack = Math.floor(Math.random() * 40);
    const lines = Math.floor(Math.random() * 40);
    return {
      matrix,
      active: { type: activeType, rotation: 0, x: spawn.x, y: spawn.y, cells: activeCells },
      hold: null,
      queue: BAG.slice(0, 5),
      stats: {
        lines,
        time,
        attack,
        pieces,
        apm: time > 0 ? attack / (time / 60) : 0,
        pps: time > 0 ? pieces / time : 0
      }
    };
  }
}

class Game {
  constructor(config) {
    this.config = config;
    this.board = new Board(config.boardWidth, config.boardHeight, config.hiddenRows);
    this.stats = new StatsTracker();
    this.callbacks = {};
    this.random = Math.random.bind(Math);
    this.multiplayerClient = null;
    this.lastSharedState = null;
    this.reset();
  }
  reset() {
    this.state = 'idle';
    this.queue = [];
    this.holdPiece = null;
    this.holdUsed = false;
    this.active = null;
    this.fallAcc = 0;
    this.lockTimer = 0;
    this.softDrop = false;
    this.areTimer = 0;
    this.combo = -1;
    this.lastClear = null;
    this.lastSharedState = null;
  }
  setCallbacks(cb) {
    this.callbacks = cb || {};
  }
  attachMultiplayer(client) {
    this.multiplayerClient = client;
  }
  start() {
    this.reset();
    this.stats.reset();
    this.stats.start();
    this.board.reset();
    this.state = 'running';
    this.ensureQueue();
    this.spawnNext();
    if (this.callbacks.state) this.callbacks.state(this.state);
    this.shareState();
  }
  update(dt) {
    if (this.state !== 'running') return;
    this.stats.update(dt);
    if (this.areTimer > 0) {
      this.areTimer -= dt;
      if (this.areTimer <= 0) this.spawnNext();
      return;
    }
    if (!this.active) return;
    const speed = this.softDrop ? this.config.softDropSpeed : this.config.gravity;
    this.fallAcc += speed * dt;
    while (this.fallAcc >= 1) {
      if (this.tryFall()) this.fallAcc -= 1;
      else {
        this.fallAcc = 0;
        break;
      }
    }
    if (this.active && !this.canFall()) {
      this.lockTimer += dt;
      if (this.lockTimer >= this.config.lockDelay) this.lockPiece();
    } else {
      this.lockTimer = 0;
    }
    this.shareState();
  }
  ensureQueue() {
    while (this.queue.length < this.config.previewCount + 1) {
      this.queue.push(...this.makeBag());
    }
  }
  makeBag() {
    const bag = [...BAG];
    for (let i = bag.length - 1; i > 0; i--) {
      const j = Math.floor(this.random() * (i + 1));
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
    return bag;
  }
  takeFromQueue() {
    this.ensureQueue();
    return this.queue.shift();
  }
  createPiece(type) {
    const piece = new Tetromino(type);
    piece.rotationState = 0;
    piece.spinState = null;
    return piece;
  }
  spawnNext() {
    const type = this.takeFromQueue();
    const piece = this.createPiece(type);
    if (!this.board.isValid(piece)) {
      this.finish();
      return;
    }
    this.active = piece;
    this.fallAcc = 0;
    this.lockTimer = 0;
    this.ensureQueue();
  }
  hold() {
    if (this.state !== 'running' || !this.active || this.holdUsed) return;
    const current = this.active.type;
    if (this.holdPiece) {
      const nextType = this.holdPiece;
      this.holdPiece = current;
      const piece = this.createPiece(nextType);
      if (!this.board.isValid(piece)) {
        this.finish();
        return;
      }
      this.active = piece;
    } else {
      this.holdPiece = current;
      this.active = null;
      this.spawnNext();
    }
    this.holdUsed = true;
    this.softDrop = false;
    this.fallAcc = 0;
    this.lockTimer = 0;
  }
  hardDrop() {
    if (this.state !== 'running' || !this.active) return;
    while (this.board.isValid(this.active, this.active.x, this.active.y + 1)) {
      this.active.y++;
    }
    this.lockPiece();
  }
  move(dir) {
    if (this.state !== 'running' || !this.active) return false;
    const nx = this.active.x + dir;
    if (!this.board.isValid(this.active, nx, this.active.y)) return false;
    this.active.x = nx;
    this.resetSpin();
    this.lockTimer = 0;
    return true;
  }
  tryFall() {
    if (!this.active) return false;
    const ny = this.active.y + 1;
    if (this.board.isValid(this.active, this.active.x, ny)) {
      this.active.y = ny;
      this.resetSpin();
      return true;
    }
    return false;
  }
  canFall() {
    return this.active && this.board.isValid(this.active, this.active.x, this.active.y + 1);
  }
  tryRotate(dir) {
    if (this.state !== 'running' || !this.active) return false;
    const piece = this.active;
    const from = piece.rotationState;
    const to = (from + dir + 4) % 4;
    const rotatedShape = piece.getShapeAtRotation(to);
    const kicks = dir === 2 ? [[0, 0]] : getKickTable(piece.type, from, to);
    const rotationType = dir === 2 ? '180' : dir === 1 ? 'cw' : 'ccw';
    for (let i = 0; i < kicks.length; i++) {
      const [kx, ky] = kicks[i];
      const testX = piece.x + kx;
      const testY = piece.y + ky;
      if (this.board.canPlace(rotatedShape, testX, testY)) {
        piece.rotationState = to;
        piece.x = testX;
        piece.y = testY;
        piece.spinState = { used: true, kick: i, type: rotationType };
        this.lockTimer = 0;
        return true;
      }
    }
    return false;
  }
  rotateCW() {
    return this.tryRotate(1);
  }
  rotateCCW() {
    return this.tryRotate(-1);
  }
  rotate180() {
    return this.tryRotate(2);
  }
  rotate(dir) {
    switch (dir) {
      case 'cw':
        return this.rotateCW();
      case 'ccw':
        return this.rotateCCW();
      case '180':
        return this.rotate180();
      default:
        return false;
    }
  }
  resetSpin() {
    if (this.active) this.active.spinState = null;
  }
  lockPiece() {
    if (!this.active) return;
    this.board.place(this.active);
    const spinResult = this.evaluateSpin(this.active);
    const clear = this.board.clearLines();
    const lines = clear.lines;
    const perfectClear = clear.perfectClear;
    this.stats.addPiece();
    let attack = 0;
    if (lines > 0) {
      this.combo += 1;
      this.stats.addLines(lines);
      attack += this.computeAttack(lines, spinResult, perfectClear);
    } else {
      this.combo = -1;
    }
    if (attack > 0) this.stats.addAttack(attack);
    if (attack > 0 && this.multiplayerClient) {
      // TODO: отправка garbage сопернику через сетевой клиент
    }
    this.lastClear = { lines, spin: spinResult, perfectClear, attack };
    this.active = null;
    this.holdUsed = false;
    this.lockTimer = 0;
    this.fallAcc = 0;
    this.softDrop = false;
    this.areTimer = lines > 0 ? this.config.lineClearAre : this.config.are;
    if (this.stats.lines >= 40) {
      this.finish();
    }
  }
  computeAttack(lines, spinResult, perfectClear) {
    let attack = 0;
    const comboIndex = Math.max(0, this.combo);
    const comboBonus = comboIndex < COMBO_ATTACK.length ? COMBO_ATTACK[comboIndex] : COMBO_ATTACK[COMBO_ATTACK.length - 1];
    const spinType = spinResult.type === 'mini' && lines >= 2 ? 't' : spinResult.type;
    switch (spinType) {
      case 't':
        if (lines === 1) attack += 2;
        else if (lines === 2) attack += 4;
        else if (lines === 3) attack += 6;
        break;
      case 'mini':
        if (lines === 1) attack += 1;
        break;
      default:
        if (lines === 2) attack += 1;
        else if (lines === 3) attack += 2;
        else if (lines === 4) attack += 4;
        break;
    }
    attack += comboBonus;
    if (perfectClear) attack += 10;
    return attack;
  }
  evaluateSpin(piece) {
    if (piece.type !== 'T' || !piece.spinState || !piece.spinState.used) return { type: 'none' };
    const center = { x: piece.x + 1, y: piece.y + 1 };
    const corners = [
      { x: center.x - 1, y: center.y - 1 },
      { x: center.x + 1, y: center.y - 1 },
      { x: center.x - 1, y: center.y + 1 },
      { x: center.x + 1, y: center.y + 1 }
    ];
    let filled = 0;
    for (const corner of corners) {
      if (!this.board.isEmpty(corner.x, corner.y)) filled++;
    }
    if (filled < 3) return { type: 'none' };
    let mini = false;
    if (piece.spinState.type !== '180') {
      mini = filled === 3 && piece.spinState.kick >= 3;
    }
    return mini ? { type: 'mini' } : { type: 't' };
  }
  setSoftDrop(active) {
    if (this.state !== 'running') return;
    this.softDrop = active;
  }
  finish() {
    if (this.state === 'finished') return;
    this.state = 'finished';
    this.active = null;
    this.areTimer = 0;
    this.softDrop = false;
    this.stats.stop();
    this.shareState();
    // TODO: сохранение статистики результатов на сервере
    if (this.callbacks.finish) this.callbacks.finish(this.getSummary());
  }
  getSummary() {
    const snap = this.stats.snapshot();
    return { time: snap.time, apm: snap.apm, pps: snap.pps, lines: snap.lines };
  }
  getRenderState() {
    const grid = this.board.getSnapshot();
    const active = this.active ? this.active.clone() : null;
    const ghost = active ? this.ghostCells(active) : null;
    return {
      grid,
      active,
      ghost,
      hold: this.holdPiece,
      queue: this.queue.slice(0, this.config.previewCount),
      stats: this.stats.snapshot(),
      state: this.state
    };
  }
  getNetworkState() {
    const matrix = this.board.getSnapshot();
    const active = this.active
      ? {
          type: this.active.type,
          rotation: this.active.rotationState,
          x: this.active.x,
          y: this.active.y,
          cells: this.active.cells().map(cell => ({ x: cell.x, y: cell.y }))
        }
      : null;
    return {
      matrix,
      active,
      hold: this.holdPiece,
      queue: this.queue.slice(0, this.config.previewCount),
      stats: this.stats.snapshot()
    };
  }
  shareState() {
    if (!this.multiplayerClient) return;
    const snapshot = this.getNetworkState();
    const serialized = JSON.stringify(snapshot);
    if (serialized === this.lastSharedState) return;
    this.lastSharedState = serialized;
    this.multiplayerClient.sendState(snapshot);
  }
  ghostCells(piece) {
    const shadow = piece.clone();
    while (this.board.isValid(shadow, shadow.x, shadow.y + 1)) shadow.y++;
    return shadow.cells();
  }
}
class BoardSnapshotRenderer {
  constructor(canvas, config) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.width = config.boardWidth;
    this.blockSize = Math.floor(canvas.width / this.width);
    this.baseRows = config.boardHeight + (config.hiddenRows || 0);
    this.totalRows = this.baseRows;
    this.ensureCanvasHeight(this.totalRows);
  }
  ensureCanvasHeight(rows) {
    if (rows <= 0) return;
    const targetRows = Math.max(rows, this.baseRows);
    const requiredHeight = targetRows * this.blockSize;
    if (this.canvas.height !== requiredHeight) {
      this.canvas.height = requiredHeight;
    }
    const cssHeight = `${requiredHeight}px`;
    if (this.canvas.style.height !== cssHeight) {
      this.canvas.style.height = cssHeight;
    }
    this.totalRows = targetRows;
  }
  clear() {
    this.ctx.fillStyle = '#050a18';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  render(snapshot) {
    const matrix = snapshot && Array.isArray(snapshot.matrix) ? snapshot.matrix : [];
    if (matrix.length > 0) {
      this.ensureCanvasHeight(matrix.length);
    } else {
      this.ensureCanvasHeight(this.baseRows);
    }
    this.clear();
    if (!snapshot) return;
    const rows = this.totalRows;
    for (let y = 0; y < rows; y++) {
      const row = matrix[y] || [];
      for (let x = 0; x < this.width; x++) {
        const cell = row[x];
        if (cell) this.drawBlock(x, y, COLORS[cell] || '#f8f9ff');
      }
    }
    if (Array.isArray(snapshot.ghostCells)) {
      this.drawCells(snapshot.ghostCells, COLORS.ghost);
    }
    if (snapshot.active && Array.isArray(snapshot.active.cells)) {
      const color = COLORS[snapshot.active.type] || '#f8f9ff';
      this.drawCells(snapshot.active.cells, color);
    }
  }
  drawCells(cells, color) {
    if (!Array.isArray(cells)) return;
    for (const cell of cells) {
      if (typeof cell.x !== 'number' || typeof cell.y !== 'number') continue;
      if (cell.y < 0 || cell.y >= this.totalRows) continue;
      if (cell.x < 0 || cell.x >= this.width) continue;
      this.drawBlock(cell.x, cell.y, color);
    }
  }
  drawBlock(x, y, color) {
    const size = this.blockSize;
    const margin = 1;
    this.ctx.fillStyle = color;
    this.ctx.fillRect(x * size + margin, y * size + margin, size - margin * 2, size - margin * 2);
  }
}

class Renderer {
  constructor(elements) {
    this.boardCanvas = elements.board;
    this.boardCtx = this.boardCanvas.getContext('2d');
    this.holdCtx = elements.hold.getContext('2d');
    this.nextCtx = elements.next.getContext('2d');
    this.hud = elements.hud;
    this.config = elements.config;
    this.cols = this.config.boardWidth;
    this.blockSize = Math.floor(this.boardCanvas.width / this.cols);
    this.baseRows = this.config.boardHeight + (this.config.hiddenRows || 0);
    this.ensureBoardCanvasHeight(this.baseRows);
  }
  ensureBoardCanvasHeight(rows) {
    if (rows <= 0) return;
    const targetRows = Math.max(rows, this.baseRows);
    const requiredHeight = targetRows * this.blockSize;
    if (this.boardCanvas.height !== requiredHeight) {
      this.boardCanvas.height = requiredHeight;
    }
    const cssHeight = `${requiredHeight}px`;
    if (this.boardCanvas.style.height !== cssHeight) {
      this.boardCanvas.style.height = cssHeight;
    }
    this.currentRows = targetRows;
  }
  render(game) {
    const state = game.getRenderState();
    this.drawBoard(state);
    this.drawHold(state.hold);
    this.drawNext(state.queue);
    this.updateHud(state.stats);
  }
  drawBoard(state) {
    const ctx = this.boardCtx;
    const cell = this.blockSize;
    const rows = state.grid.length;
    this.ensureBoardCanvasHeight(rows);
    const totalRows = this.currentRows || rows;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.fillStyle = '#0b1324';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    for (let y = 0; y < totalRows; y++) {
      for (let x = 0; x < this.cols; x++) {
        ctx.strokeRect(x * cell, y * cell, cell, cell);
      }
    }
    const drawCells = (cells, color, alpha = 1) => {
      if (!Array.isArray(cells)) return;
      ctx.fillStyle = color;
      ctx.globalAlpha = alpha;
      for (const c of cells) {
        if (!c) continue;
        if (c.y < 0 || c.y >= totalRows) continue;
        if (c.x < 0 || c.x >= this.cols) continue;
        ctx.fillRect(c.x * cell, c.y * cell, cell, cell);
      }
      ctx.globalAlpha = 1;
    };
    for (let y = 0; y < totalRows; y++) {
      const row = state.grid[y] || [];
      const cols = Math.min(row.length, this.cols);
      for (let x = 0; x < cols; x++) {
        const type = row[x];
        if (type) {
          ctx.fillStyle = COLORS[type];
          ctx.fillRect(x * cell, y * cell, cell, cell);
        }
      }
    }
    if (state.ghost) drawCells(state.ghost, COLORS.ghost, 1);
    if (state.active) drawCells(state.active.cells(), COLORS[state.active.type]);
  }
  drawHold(type) {
    const ctx = this.holdCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (!type) return;
    ctx.save();
    this.drawMini(ctx, type, ctx.canvas.width, ctx.canvas.height);
    ctx.restore();
  }
  drawNext(queue) {
    const ctx = this.nextCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    queue.forEach((type, index) => {
      ctx.save();
      ctx.translate(0, index * 80);
      this.drawMini(ctx, type, ctx.canvas.width, 80);
      ctx.restore();
    });
  }
  drawMini(ctx, type, boxWidth = ctx.canvas.width, boxHeight = ctx.canvas.height) {
    const size = 28;
    const shape = TETROMINO_SHAPES[type][0];
    const minX = Math.min(...shape.map(c => c[0]));
    const maxX = Math.max(...shape.map(c => c[0]));
    const minY = Math.min(...shape.map(c => c[1]));
    const maxY = Math.max(...shape.map(c => c[1]));
    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    const offsetX = (boxWidth - width * size) / 2;
    const offsetY = (boxHeight - height * size) / 2;
    ctx.fillStyle = COLORS[type];
    for (const [dx, dy] of shape) {
      ctx.fillRect(offsetX + (dx - minX) * size, offsetY + (dy - minY) * size, size - 2, size - 2);
    }
  }
  updateHud(stats) {
    const { lines, time, apm, pps } = stats;
    this.hud.lines.textContent = lines;
    this.hud.time.textContent = formatTime(time);
    this.hud.apm.textContent = apm.toFixed(2);
    this.hud.pps.textContent = pps.toFixed(2);
  }
}

class InputManager {
  constructor(game, settingsStore) {
    this.game = game;
    this.config = game.config;
    this.store = settingsStore;
    this.bindings = {};
    this.left = false;
    this.right = false;
    this.lastDir = 0;
    this.dasTimer = 0;
    this.arrTimer = 0;
    this.softDrop = false;
    this.refreshBindings();
    window.addEventListener('keydown', (e) => this.onKeyDown(e));
    window.addEventListener('keyup', (e) => this.onKeyUp(e));
  }
  refreshBindings() {
    const bindings = this.store.getBindings();
    this.bindingsByKey = {};
    Object.entries(bindings).forEach(([action, code]) => {
      if (code) this.bindingsByKey[code] = action;
    });
  }
  onKeyDown(e) {
    const action = this.bindingsByKey[e.code];
    if (!action) return;
    e.preventDefault();
    switch (action) {
      case 'moveLeft':
        if (e.repeat) return;
        this.left = true;
        this.lastDir = -1;
        this.dasTimer = 0;
        this.arrTimer = 0;
        this.game.move(-1);
        break;
      case 'moveRight':
        if (e.repeat) return;
        this.right = true;
        this.lastDir = 1;
        this.dasTimer = 0;
        this.arrTimer = 0;
        this.game.move(1);
        break;
      case 'softDrop':
        this.softDrop = true;
        this.game.setSoftDrop(true);
        break;
      case 'hardDrop':
        if (e.repeat) return;
        this.game.hardDrop();
        break;
      case 'rotateCW':
        if (e.repeat) return;
        this.game.rotateCW();
        break;
      case 'rotateCCW':
        if (e.repeat) return;
        this.game.rotateCCW();
        break;
      case 'rotate180':
        if (e.repeat) return;
        this.game.rotate180();
        break;
      case 'hold':
        if (e.repeat) return;
        this.game.hold();
        break;
      default:
        break;
    }
  }
  onKeyUp(e) {
    const action = this.bindingsByKey[e.code];
    if (!action) return;
    switch (action) {
      case 'moveLeft':
        this.left = false;
        this.dasTimer = 0;
        this.arrTimer = 0;
        break;
      case 'moveRight':
        this.right = false;
        this.dasTimer = 0;
        this.arrTimer = 0;
        break;
      case 'softDrop':
        this.softDrop = false;
        this.game.setSoftDrop(false);
        break;
      default:
        break;
    }
  }
  update(dt) {
    this.game.setSoftDrop(this.softDrop);
    const dir = this.getHorizontalDir();
    if (dir === 0) {
      this.dasTimer = 0;
      this.arrTimer = 0;
      return;
    }
    this.dasTimer += dt;
    if (this.dasTimer < this.config.das) return;
    if (this.config.arr === 0) {
      this.game.move(dir);
      return;
    }
    this.arrTimer += dt;
    while (this.arrTimer >= this.config.arr) {
      if (!this.game.move(dir)) {
        this.arrTimer = 0;
        break;
      }
      this.arrTimer -= this.config.arr;
    }
  }
  getHorizontalDir() {
    if (this.left && this.right) return this.lastDir;
    if (this.left) return -1;
    if (this.right) return 1;
    return 0;
  }
}

function formatTime(seconds) {
  const total = Math.max(0, seconds);
  const minutes = Math.floor(total / 60);
  const secs = total - minutes * 60;
  const whole = Math.floor(secs);
  const cent = Math.floor((secs - whole) * 100);
  return `${String(minutes).padStart(2, '0')}:${String(whole).padStart(2, '0')}.${String(cent).padStart(2, '0')}`;
}
class MatchmakingUI {
  constructor({ locale, client, game, config }) {
    this.locale = locale;
    this.client = client;
    this.game = game;
    this.config = config;
    this.elements = {
      description: document.getElementById('matchDescription'),
      input: document.getElementById('roomCodeInput'),
      joinBtn: document.getElementById('joinRoomBtn'),
      createBtn: document.getElementById('createRoomBtn'),
      roomCode: document.getElementById('matchRoomCode'),
      boards: document.getElementById('matchBoards'),
      localTitle: document.getElementById('localBoardTitle'),
      remoteTitle: document.getElementById('remoteBoardTitle'),
      localCanvas: document.getElementById('localMatchBoard'),
      remoteCanvas: document.getElementById('remoteMatchBoard'),
      localStats: document.getElementById('localBoardStats'),
      remoteStats: document.getElementById('remoteBoardStats')
    };
    this.roomCode = null;
    this.roomMode = 'idle';
    this.remoteState = null;
    this.localRenderer = new BoardSnapshotRenderer(this.elements.localCanvas, config);
    this.remoteRenderer = new BoardSnapshotRenderer(this.elements.remoteCanvas, config);
    this.attachEvents();
    this.client.onRemoteState((state) => {
      this.remoteState = state;
      this.renderRemote();
    });
    this.client.onGarbage(() => {
      // TODO: отправка garbage будет обрабатываться при подключении сервера
    });
    this.refreshText();
    this.updateStatusText();
  }
  attachEvents() {
    this.elements.joinBtn.addEventListener('click', () => this.handleJoin());
    this.elements.createBtn.addEventListener('click', () => this.handleCreate());
    this.elements.input.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        this.handleJoin();
      }
    });
  }
  refreshText() {
    this.elements.joinBtn.textContent = this.locale.t('match.join');
    this.elements.createBtn.textContent = this.locale.t('match.create');
    this.elements.input.placeholder = this.locale.t('match.placeholder');
    this.elements.localTitle.textContent = this.locale.t('match.localPlayer');
    this.elements.remoteTitle.textContent = this.locale.t('match.remotePlayer');
    if (this.roomCode) {
      this.elements.roomCode.textContent = this.locale.t(
        this.roomMode === 'created' ? 'match.createSuccess' : 'match.joinSuccess',
        { code: this.roomCode }
      );
    }
    this.updateStatusText();
    this.renderRemote();
  }
  handleJoin() {
    const code = this.elements.input.value.trim().toUpperCase();
    if (!code) {
      this.roomMode = 'needCode';
      this.updateStatusText();
      return;
    }
    this.roomMode = 'connecting';
    this.updateStatusText();
    this.client.joinRoom(code)
      .then(() => {
        this.roomCode = code;
        this.roomMode = 'joined';
        this.onRoomReady();
      })
      .catch(() => {
        this.roomMode = 'error';
        this.updateStatusText();
      });
  }
  handleCreate() {
    const code = this.generateCode();
    this.elements.input.value = code;
    this.roomMode = 'connecting';
    this.updateStatusText();
    this.client.createRoom(code)
      .then(() => {
        this.roomCode = code;
        this.roomMode = 'created';
        this.onRoomReady();
      })
      .catch(() => {
        this.roomMode = 'error';
        this.updateStatusText();
      });
  }
  onRoomReady() {
    this.elements.roomCode.textContent = this.locale.t(
      this.roomMode === 'created' ? 'match.createSuccess' : 'match.joinSuccess',
      { code: this.roomCode }
    );
    this.elements.boards.classList.remove('hidden');
    this.renderLocal(this.game);
    this.renderRemote();
    this.updateStatusText();
  }
  leaveRoom() {
    this.roomCode = null;
    this.roomMode = 'idle';
    this.remoteState = null;
    this.elements.roomCode.textContent = '';
    this.elements.boards.classList.add('hidden');
    this.client.disconnect();
    this.updateStatusText();
    this.renderRemote();
  }
  updateStatusText() {
    let key = 'match.statusIdle';
    switch (this.roomMode) {
      case 'connecting':
        key = 'match.statusConnecting';
        break;
      case 'needCode':
        key = 'match.statusNeedCode';
        break;
      case 'error':
        key = 'match.statusError';
        break;
      case 'created':
        key = 'match.createSuccess';
        break;
      case 'joined':
        key = 'match.joinSuccess';
        break;
      default:
        key = 'match.statusIdle';
        break;
    }
    const params = this.roomCode ? { code: this.roomCode } : {};
    this.elements.description.textContent = this.locale.t(key, params);
  }
  renderLocal(game) {
    const state = game.getRenderState();
    this.localRenderer.render({
      matrix: state.grid,
      active: state.active
        ? { type: state.active.type, cells: state.active.cells() }
        : null,
      ghostCells: state.ghost
    });
    this.elements.localStats.textContent = this.formatStats(state.stats);
  }
  renderRemote() {
    if (!this.remoteState) {
      this.remoteRenderer.clear();
      this.elements.remoteStats.textContent = this.locale.t('match.waitingOpponent');
      return;
    }
    this.remoteRenderer.render({
      matrix: this.remoteState.matrix,
      active: this.remoteState.active,
      ghostCells: this.remoteState.ghost || null
    });
    this.elements.remoteStats.textContent = this.formatStats(this.remoteState.stats);
  }
  formatStats(stats) {
    if (!stats) return '—';
    const lines = Number.isFinite(stats.lines) ? stats.lines : 0;
    const time = Number.isFinite(stats.time) ? stats.time : 0;
    const apm = Number.isFinite(stats.apm) ? stats.apm : 0;
    const pps = Number.isFinite(stats.pps) ? stats.pps : 0;
    return `LINES: ${lines} | TIME: ${formatTime(time)} | APM: ${apm.toFixed(1)} | PPS: ${pps.toFixed(2)}`;
  }
  generateCode() {
    const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) {
      code += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return code;
  }
}
class App {
  constructor() {
    this.locale = new Localization(i18n, 'ru');
    this.settingsStore = new SettingsStore('ru-tetris-binds', DEFAULT_BINDINGS);
    this.screenManager = new ScreenManager();
    this.game = new Game(CONFIG);
    this.multiplayer = new MultiplayerClient();
    this.multiplayer.configure(CONFIG);
    this.game.attachMultiplayer(this.multiplayer);
    const hud = {
      lines: document.getElementById('linesVal'),
      time: document.getElementById('timeVal'),
      apm: document.getElementById('apmVal'),
      pps: document.getElementById('ppsVal')
    };
    this.renderer = new Renderer({
      board: document.getElementById('boardCanvas'),
      hold: document.getElementById('holdCanvas'),
      next: document.getElementById('nextCanvas'),
      hud,
      config: CONFIG
    });
    this.matchmaking = new MatchmakingUI({
      locale: this.locale,
      client: this.multiplayer,
      game: this.game,
      config: CONFIG
    });
    this.input = new InputManager(this.game, this.settingsStore);
    this.settingsUI = new SettingsUI(
      document.getElementById('settingsList'),
      this.settingsStore,
      this.locale,
      () => this.input.refreshBindings()
    );
    this.bindUI();
    this.game.setCallbacks({
      finish: (summary) => this.showResults(summary)
    });
    this.lastFrame = performance.now();
    requestAnimationFrame((ts) => this.loop(ts));
  }
  bindUI() {
    const menuPlayBtn = document.getElementById('menuPlayBtn');
    const menuMatchBtn = document.getElementById('menuMatchBtn');
    const menuSettingsBtn = document.getElementById('menuSettingsBtn');
    const menuLoginBtn = document.getElementById('menuLoginBtn');
    const gameBackBtn = document.getElementById('gameBackBtn');
    const settingsBackBtn = document.getElementById('settingsBackBtn');
    const matchBackBtn = document.getElementById('matchBackBtn');
    const loginBackBtn = document.getElementById('loginBackBtn');
    const menuHint = document.getElementById('menuHint');

    menuPlayBtn.textContent = this.locale.t('menu.play40');
    menuMatchBtn.textContent = this.locale.t('menu.matchmaking');
    menuSettingsBtn.textContent = this.locale.t('menu.settings');
    menuLoginBtn.textContent = this.locale.t('menu.login');
    menuHint.textContent = this.locale.t('menu.hint');

    document.getElementById('settingsTitle').textContent = this.locale.t('settings.title');
    document.getElementById('settingsHint').textContent = this.locale.t('settings.hint');
    settingsBackBtn.textContent = this.locale.t('match.back');

    document.getElementById('matchTitle').textContent = this.locale.t('match.title');
    document.getElementById('matchDescription').textContent = this.locale.t('match.description');
    matchBackBtn.textContent = this.locale.t('match.back');

    document.getElementById('loginTitle').textContent = this.locale.t('login.title');
    document.getElementById('loginDescription').textContent = this.locale.t('login.description');
    loginBackBtn.textContent = this.locale.t('login.back');

    gameBackBtn.textContent = this.locale.t('game.back');

    menuPlayBtn.addEventListener('click', () => this.startFortyLines());
    menuMatchBtn.addEventListener('click', () => {
      this.matchmaking.refreshText();
      this.openScreen('matchScreen');
    });
    menuSettingsBtn.addEventListener('click', () => {
      this.settingsUI.refresh();
      this.openScreen('settingsScreen');
    });
    menuLoginBtn.addEventListener('click', () => {
      // TODO: авторизация по нику и синхронизация профиля через backend
      this.openScreen('loginScreen');
    });

    settingsBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));
    matchBackBtn.addEventListener('click', () => {
      this.matchmaking.leaveRoom();
      this.openScreen('mainMenu');
    });
    loginBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));
    gameBackBtn.addEventListener('click', () => this.openScreen('mainMenu'));

    document.getElementById('resultMenuBtn').textContent = this.locale.t('result.toMenu');
    document.getElementById('resultTitle').textContent = this.locale.t('result.title');
    document.getElementById('resultMenuBtn').addEventListener('click', () => {
      this.hideOverlay();
      this.openScreen('mainMenu');
    });
  }
  openScreen(id) {
    const element = document.getElementById(id);
    this.screenManager.show(element);
    if (id !== 'gameScreen' && this.game.state === 'running') {
      this.game.finish();
      this.hideOverlay();
    }
    if (id === 'gameScreen' && this.game.state !== 'running') {
      this.hideOverlay();
      this.game.start();
    }
  }
  startFortyLines() {
    this.openScreen('gameScreen');
  }
  showResults(summary) {
    const overlay = document.getElementById('resultOverlay');
    const resultStats = document.getElementById('resultStats');
    resultStats.innerHTML = `LINES: ${summary.lines}<br>TIME: ${formatTime(summary.time)}<br>APM: ${summary.apm.toFixed(2)}<br>PPS: ${summary.pps.toFixed(2)}`;
    overlay.classList.remove('hidden');
  }
  hideOverlay() {
    document.getElementById('resultOverlay').classList.add('hidden');
  }
  loop(timestamp) {
    const dt = (timestamp - this.lastFrame) / 1000;
    this.lastFrame = timestamp;
    this.input.update(dt);
    this.game.update(dt);
    this.renderer.render(this.game);
    this.matchmaking.renderLocal(this.game);
    requestAnimationFrame((ts) => this.loop(ts));
  }
}

new App();
})();
</script>
</body>
</html>
